{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "ba81f6cb",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-11T15:35:58.428937Z",
     "iopub.status.busy": "2024-09-11T15:35:58.428640Z",
     "iopub.status.idle": "2024-09-11T15:36:00.807699Z",
     "shell.execute_reply": "2024-09-11T15:36:00.806688Z"
    },
    "papermill": {
     "duration": 2.386403,
     "end_time": "2024-09-11T15:36:00.810153",
     "exception": false,
     "start_time": "2024-09-11T15:35:58.423750",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Ariel Data Challenge 2024: Exoplanet Spectrum Analysis Pipeline\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy import signal\n",
    "from scipy.ndimage import gaussian_filter1d\n",
    "from scipy.optimize import minimize\n",
    "from scipy.signal import savgol_filter\n",
    "from scipy.interpolate import interp1d\n",
    "from sklearn.decomposition import PCA\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.linear_model import LinearRegression\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "from sklearn.metrics import mean_squared_error, r2_score\n",
    "import gc\n",
    "import logging"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "d2708f18",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-11T15:36:00.819029Z",
     "iopub.status.busy": "2024-09-11T15:36:00.818580Z",
     "iopub.status.idle": "2024-09-11T15:36:00.824497Z",
     "shell.execute_reply": "2024-09-11T15:36:00.823719Z"
    },
    "papermill": {
     "duration": 0.01227,
     "end_time": "2024-09-11T15:36:00.826425",
     "exception": false,
     "start_time": "2024-09-11T15:36:00.814155",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 1. Data Loading Functions\n",
    "\n",
    "def load_planet_data(planet_id, data_path):\n",
    "    airs_signal = pd.read_parquet(f\"{data_path}/train/{planet_id}/AIRS-CH0_signal.parquet\")\n",
    "    fgs1_signal = pd.read_parquet(f\"{data_path}/train/{planet_id}/FGS1_signal.parquet\")\n",
    "    \n",
    "    calibration_files = {\n",
    "        'dark': pd.read_parquet(f\"{data_path}/train/{planet_id}/AIRS-CH0_calibration/dark.parquet\"),\n",
    "        'flat': pd.read_parquet(f\"{data_path}/train/{planet_id}/AIRS-CH0_calibration/flat.parquet\"),\n",
    "        'dead': pd.read_parquet(f\"{data_path}/train/{planet_id}/AIRS-CH0_calibration/dead.parquet\"),\n",
    "        'linear_corr': pd.read_parquet(f\"{data_path}/train/{planet_id}/AIRS-CH0_calibration/linear_corr.parquet\")\n",
    "    }\n",
    "    \n",
    "    return airs_signal, fgs1_signal, calibration_files"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "f9749440",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-11T15:36:00.834699Z",
     "iopub.status.busy": "2024-09-11T15:36:00.834429Z",
     "iopub.status.idle": "2024-09-11T15:36:00.846538Z",
     "shell.execute_reply": "2024-09-11T15:36:00.845723Z"
    },
    "papermill": {
     "duration": 0.018648,
     "end_time": "2024-09-11T15:36:00.848457",
     "exception": false,
     "start_time": "2024-09-11T15:36:00.829809",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 2. Data Preprocessing Functions\n",
    "\n",
    "def reshape_and_calibrate(airs_signal, calibration_files):\n",
    "    airs_data = airs_signal.values.reshape(-1, 32, 356)\n",
    "    airs_data = (airs_data - calibration_files['dark'].values) / calibration_files['flat'].values\n",
    "    return airs_data\n",
    "\n",
    "def extract_spectral_data(airs_data):\n",
    "    return np.mean(airs_data, axis=1)\n",
    "\n",
    "def measure_centroid(image):\n",
    "    y, x = np.indices(image.shape)\n",
    "    total = image.sum()\n",
    "    x_center = (x * image).sum() / total\n",
    "    y_center = (y * image).sum() / total\n",
    "    return x_center, y_center\n",
    "\n",
    "def correct_jitter(airs_data, fgs1_data, airs_time, fgs1_time):\n",
    "    # Ensure FGS1 data covers the full AIRS-CH0 time range\n",
    "    fgs1_start = max(fgs1_time.min(), airs_time.min())\n",
    "    fgs1_end = min(fgs1_time.max(), airs_time.max())\n",
    "    mask = (fgs1_time >= fgs1_start) & (fgs1_time <= fgs1_end)\n",
    "    fgs1_time = fgs1_time[mask]\n",
    "    fgs1_data = fgs1_data[mask]\n",
    "\n",
    "    # Interpolate FGS1 centroid positions to AIRS-CH0 timestamps\n",
    "    interp_x = interp1d(fgs1_time, fgs1_data[:, 0], kind='cubic', fill_value='extrapolate')\n",
    "    interp_y = interp1d(fgs1_time, fgs1_data[:, 1], kind='cubic', fill_value='extrapolate')\n",
    "    \n",
    "    x_pos = interp_x(airs_time)\n",
    "    y_pos = interp_y(airs_time)\n",
    "\n",
    "    # Smooth the centroid positions to reduce noise\n",
    "    x_smooth = savgol_filter(x_pos, window_length=51, polyorder=3)\n",
    "    y_smooth = savgol_filter(y_pos, window_length=51, polyorder=3)\n",
    "\n",
    "    # Calculate pixel shifts\n",
    "    x_shift = x_smooth - np.median(x_smooth)\n",
    "    y_shift = y_smooth - np.median(y_smooth)\n",
    "\n",
    "    # Correct AIRS-CH0 data for jitter\n",
    "    corrected_data = np.zeros_like(airs_data)\n",
    "    for i in range(airs_data.shape[1]):\n",
    "        # Create a 2D interpolation function for each wavelength\n",
    "        interp_func = interp1d(airs_time, airs_data[:, i], kind='cubic', fill_value='extrapolate')\n",
    "        \n",
    "        # Apply correction\n",
    "        corrected_time = airs_time - x_shift * 0.1 - y_shift * 0.1  # Adjust scaling factors as needed\n",
    "        corrected_data[:, i] = interp_func(corrected_time)\n",
    "\n",
    "    return corrected_data\n",
    "\n",
    "def normalize_data(data):\n",
    "    mean = np.mean(data, axis=0)\n",
    "    std = np.std(data, axis=0)\n",
    "    return (data - mean) / (std + 1e-10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "e391ce19",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-11T15:36:00.856658Z",
     "iopub.status.busy": "2024-09-11T15:36:00.856396Z",
     "iopub.status.idle": "2024-09-11T15:36:00.868548Z",
     "shell.execute_reply": "2024-09-11T15:36:00.867741Z"
    },
    "papermill": {
     "duration": 0.018598,
     "end_time": "2024-09-11T15:36:00.870428",
     "exception": false,
     "start_time": "2024-09-11T15:36:00.851830",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 3. Model Building Functions\n",
    "\n",
    "def simple_transit_model(params, time):\n",
    "    t0, per, depth, duration = params\n",
    "    phase = (time - t0 + 0.5*per) % per - 0.5*per\n",
    "    transit = np.abs(phase) < 0.5*duration\n",
    "    return 1 - depth * transit\n",
    "\n",
    "def fit_transit_model(flux, time):\n",
    "    def residuals(params):\n",
    "        return np.sum((flux - simple_transit_model(params, time))**2)\n",
    "    \n",
    "    initial_guess = [np.median(time), 0.1 * (time[-1] - time[0]), 0.01, 0.1 * (time[-1] - time[0])]\n",
    "    bounds = ((0, len(time)), (0, len(time)), (0, 0.1), (0, len(time)/2))\n",
    "    result = minimize(residuals, initial_guess, bounds=bounds, method='L-BFGS-B')\n",
    "    return result.x\n",
    "\n",
    "def process_planet(planet_id, data_path, axis_info):\n",
    "    # Load data\n",
    "    airs_signal, fgs1_signal, calibration_files = load_planet_data(planet_id, data_path)\n",
    "    \n",
    "    # Preprocess data\n",
    "    airs_data = reshape_and_calibrate(airs_signal, calibration_files)\n",
    "    spectral_data = extract_spectral_data(airs_data)\n",
    "    \n",
    "    # Time arrays\n",
    "    airs_time_step = axis_info['AIRS-CH0-axis0-h'].iloc[1] - axis_info['AIRS-CH0-axis0-h'].iloc[0]\n",
    "    time = np.arange(len(spectral_data)) * airs_time_step\n",
    "    \n",
    "    fgs1_data = fgs1_signal.values.reshape(-1, 32, 32)\n",
    "    fgs1_centroids = np.array([measure_centroid(frame) for frame in fgs1_data])\n",
    "    fgs1_time_step = axis_info['FGS1-axis0-h'].iloc[1] - axis_info['FGS1-axis0-h'].iloc[0]\n",
    "    fgs1_time = np.arange(len(fgs1_data)) * fgs1_time_step\n",
    "    \n",
    "    # Jitter correction\n",
    "    corrected_spectral_data = correct_jitter(spectral_data, fgs1_centroids, time, fgs1_time)\n",
    "    \n",
    "    # Fit transit model for each wavelength\n",
    "    transit_params = np.array([fit_transit_model(corrected_spectral_data[:, i], time) \n",
    "                               for i in range(corrected_spectral_data.shape[1])])\n",
    "    \n",
    "    # Extract spectrum and estimate uncertainties\n",
    "    spectrum = np.mean(corrected_spectral_data, axis=0)\n",
    "    uncertainties = np.std(corrected_spectral_data, axis=0) / np.sqrt(len(corrected_spectral_data))\n",
    "    \n",
    "    return {\n",
    "        'wavelengths': pd.read_csv(f\"{data_path}/wavelengths.csv\").iloc[0].values,\n",
    "        'spectrum': spectrum,\n",
    "        'uncertainties': uncertainties,\n",
    "        'transit_params': transit_params\n",
    "    }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "f15fe2bb",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-11T15:36:00.878762Z",
     "iopub.status.busy": "2024-09-11T15:36:00.878460Z",
     "iopub.status.idle": "2024-09-11T15:36:00.883539Z",
     "shell.execute_reply": "2024-09-11T15:36:00.882737Z"
    },
    "papermill": {
     "duration": 0.011454,
     "end_time": "2024-09-11T15:36:00.885547",
     "exception": false,
     "start_time": "2024-09-11T15:36:00.874093",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 4. Main Processing Loop\n",
    "\n",
    "def process_all_planets(data_path, results_path, train_adc_info, axis_info):\n",
    "    total_planets = len(train_adc_info.index)\n",
    "    for i, planet_id in enumerate(train_adc_info.index, 1):\n",
    "        results = process_planet(str(planet_id), data_path, axis_info)\n",
    "        if results is not None:\n",
    "            np.savez(f\"{results_path}/planet_{planet_id}_results.npz\", **results)\n",
    "        gc.collect()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "8541e8f3",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-11T15:36:00.894173Z",
     "iopub.status.busy": "2024-09-11T15:36:00.893842Z",
     "iopub.status.idle": "2024-09-11T15:36:00.902451Z",
     "shell.execute_reply": "2024-09-11T15:36:00.901631Z"
    },
    "papermill": {
     "duration": 0.015263,
     "end_time": "2024-09-11T15:36:00.904330",
     "exception": false,
     "start_time": "2024-09-11T15:36:00.889067",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 5. Model Evaluation and Analysis\n",
    "\n",
    "def load_processed_results(results_path, planet_ids):\n",
    "    all_results = {}\n",
    "    for planet_id in planet_ids:\n",
    "        all_results[planet_id] = np.load(f\"{results_path}/planet_{planet_id}_results.npz\", allow_pickle=True)\n",
    "    return all_results\n",
    "\n",
    "def prepare_data_for_modeling(all_results):\n",
    "    X = np.array([results['spectrum'] for results in all_results.values()])\n",
    "    y = np.array([results['transit_params'][:, 2] for results in all_results.values()])  # Using transit depth as target\n",
    "    return X, y\n",
    "\n",
    "def train_and_evaluate_models(X, y):\n",
    "    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n",
    "    \n",
    "    # PCA\n",
    "    pca = PCA(n_components=0.95)\n",
    "    X_train_pca = pca.fit_transform(X_train)\n",
    "    X_test_pca = pca.transform(X_test)\n",
    "    \n",
    "    # Linear Regression\n",
    "    lr = LinearRegression()\n",
    "    lr.fit(X_train_pca, y_train)\n",
    "    lr_score = lr.score(X_test_pca, y_test)\n",
    "    \n",
    "    # Random Forest\n",
    "    rf = RandomForestRegressor(n_estimators=100, random_state=42)\n",
    "    rf.fit(X_train_pca, y_train)\n",
    "    rf_score = rf.score(X_test_pca, y_test)\n",
    "    \n",
    "    print(f\"Linear Regression R2 Score: {lr_score:.4f}\")\n",
    "    print(f\"Random Forest R2 Score: {rf_score:.4f}\")\n",
    "    \n",
    "    return lr, rf, pca, X_test_pca, y_test"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "2412d84e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-11T15:36:00.912575Z",
     "iopub.status.busy": "2024-09-11T15:36:00.912242Z",
     "iopub.status.idle": "2024-09-11T15:36:00.917567Z",
     "shell.execute_reply": "2024-09-11T15:36:00.916784Z"
    },
    "papermill": {
     "duration": 0.011578,
     "end_time": "2024-09-11T15:36:00.919420",
     "exception": false,
     "start_time": "2024-09-11T15:36:00.907842",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 5.2. Final Model Selection\n",
    "\n",
    "def select_best_model(lr_model, rf_model, X_test_pca, y_test):\n",
    "    lr_mse = mean_squared_error(y_test, lr_model.predict(X_test_pca))\n",
    "    rf_mse = mean_squared_error(y_test, rf_model.predict(X_test_pca))\n",
    "    \n",
    "    print(f\"Linear Regression MSE: {lr_mse:.6f}\")\n",
    "    print(f\"Random Forest MSE: {rf_mse:.6f}\")\n",
    "    \n",
    "    if lr_mse < rf_mse:\n",
    "        print(\"Linear Regression model selected.\")\n",
    "        return lr_model\n",
    "    else:\n",
    "        print(\"Random Forest model selected.\")\n",
    "        return rf_model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "71802b6f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-11T15:36:00.927798Z",
     "iopub.status.busy": "2024-09-11T15:36:00.927514Z",
     "iopub.status.idle": "2024-09-11T15:36:00.934533Z",
     "shell.execute_reply": "2024-09-11T15:36:00.933677Z"
    },
    "papermill": {
     "duration": 0.013366,
     "end_time": "2024-09-11T15:36:00.936421",
     "exception": false,
     "start_time": "2024-09-11T15:36:00.923055",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 5.4. Uncertainty Estimation\n",
    "\n",
    "def estimate_uncertainty(model, X_pca, n_bootstrap=100):\n",
    "    predictions = []\n",
    "    for _ in range(n_bootstrap):\n",
    "        if isinstance(model, RandomForestRegressor):\n",
    "            # Randomly select estimators and average their predictions\n",
    "            n_estimators = len(model.estimators_)\n",
    "            selected_estimators = np.random.choice(model.estimators_, size=n_estimators, replace=True)\n",
    "            preds = np.mean([estimator.predict(X_pca) for estimator in selected_estimators], axis=0)\n",
    "        elif isinstance(model, LinearRegression):\n",
    "            # Add noise to the coefficients\n",
    "            coef_noise = np.random.normal(0, 0.1, size=model.coef_.shape)\n",
    "            preds = X_pca @ (model.coef_ + coef_noise).T + model.intercept_\n",
    "        else:\n",
    "            raise ValueError(\"Unsupported model type\")\n",
    "        predictions.append(preds)\n",
    "    \n",
    "    return np.std(predictions, axis=0)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "ec3cee84",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-11T15:36:00.944670Z",
     "iopub.status.busy": "2024-09-11T15:36:00.944409Z",
     "iopub.status.idle": "2024-09-11T15:36:00.951643Z",
     "shell.execute_reply": "2024-09-11T15:36:00.950714Z"
    },
    "papermill": {
     "duration": 0.013624,
     "end_time": "2024-09-11T15:36:00.953626",
     "exception": false,
     "start_time": "2024-09-11T15:36:00.940002",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 5.6. Submission Preparation\n",
    "\n",
    "def prepare_submission(model, pca_model, all_results, output_file):\n",
    "    planet_ids = list(all_results.keys())\n",
    "    spectra = []\n",
    "    uncertainties = []\n",
    "    \n",
    "    for planet_id in planet_ids:\n",
    "        spectrum = all_results[planet_id]['spectrum']\n",
    "        spectrum_pca = pca_model.transform(spectrum.reshape(1, -1))\n",
    "        predicted_spectrum = model.predict(spectrum_pca).flatten()\n",
    "        spectrum_uncertainty = estimate_uncertainty(model, spectrum_pca)\n",
    "        \n",
    "        # Ensure the predicted spectrum and uncertainty have the correct shape\n",
    "        if predicted_spectrum.ndim == 2:\n",
    "            predicted_spectrum = predicted_spectrum[0]\n",
    "        if spectrum_uncertainty.ndim == 2:\n",
    "            spectrum_uncertainty = spectrum_uncertainty[0]\n",
    "        \n",
    "        spectra.append(predicted_spectrum)\n",
    "        uncertainties.append(spectrum_uncertainty)\n",
    "    \n",
    "    submission_df = pd.DataFrame({\n",
    "        'planet_id': planet_ids,\n",
    "        'spectrum': spectra,\n",
    "        'uncertainty': uncertainties\n",
    "    })\n",
    "    \n",
    "    submission_df.to_csv(output_file, index=False)\n",
    "    print(f\"Submission file saved to {output_file}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "48599a5a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-11T15:36:00.962160Z",
     "iopub.status.busy": "2024-09-11T15:36:00.961910Z",
     "iopub.status.idle": "2024-09-11T15:36:00.970345Z",
     "shell.execute_reply": "2024-09-11T15:36:00.969494Z"
    },
    "papermill": {
     "duration": 0.014849,
     "end_time": "2024-09-11T15:36:00.972242",
     "exception": false,
     "start_time": "2024-09-11T15:36:00.957393",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 5.8. Model Interpretation and Visualization\n",
    "\n",
    "def visualize_important_features(model, pca_model, wavelengths):\n",
    "    if isinstance(model, RandomForestRegressor):\n",
    "        importance = model.feature_importances_\n",
    "    elif isinstance(model, LinearRegression):\n",
    "        importance = np.abs(model.coef_[0])\n",
    "    \n",
    "    # Transform importance back to original feature space\n",
    "    original_importance = pca_model.inverse_transform(importance)\n",
    "    \n",
    "    plt.figure(figsize=(12, 6))\n",
    "    plt.plot(wavelengths, original_importance)\n",
    "    plt.title('Feature Importance Across Wavelengths')\n",
    "    plt.xlabel('Wavelength')\n",
    "    plt.ylabel('Importance')\n",
    "    plt.show()\n",
    "\n",
    "def plot_example_prediction(model, pca_model, all_results, planet_id):\n",
    "    spectrum = all_results[planet_id]['spectrum']\n",
    "    actual_params = all_results[planet_id]['transit_params']\n",
    "    \n",
    "    spectrum_pca = pca_model.transform(spectrum.reshape(1, -1))\n",
    "    predicted_params = model.predict(spectrum_pca).flatten()\n",
    "    \n",
    "    plt.figure(figsize=(12, 6))\n",
    "    plt.plot(spectrum, label='Actual Spectrum')\n",
    "    plt.plot(predicted_params, label='Predicted Transit Depth')\n",
    "    plt.title(f'Spectrum and Predicted Transit Depth for Planet {planet_id}')\n",
    "    plt.xlabel('Wavelength Index')\n",
    "    plt.ylabel('Value')\n",
    "    plt.legend()\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "0a2cb85b",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-11T15:36:00.980965Z",
     "iopub.status.busy": "2024-09-11T15:36:00.980681Z",
     "iopub.status.idle": "2024-09-11T18:15:55.846075Z",
     "shell.execute_reply": "2024-09-11T18:15:55.845193Z"
    },
    "papermill": {
     "duration": 9594.872097,
     "end_time": "2024-09-11T18:15:55.848181",
     "exception": false,
     "start_time": "2024-09-11T15:36:00.976084",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Linear Regression R2 Score: -0.0013\n",
      "Random Forest R2 Score: 0.5081\n",
      "Linear Regression MSE: 0.001128\n",
      "Random Forest MSE: 0.000528\n",
      "Random Forest model selected.\n",
      "Submission file saved to submission.csv\n"
     ]
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAA+AAAAH/CAYAAADXOLcaAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuNSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/xnp5ZAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAh80lEQVR4nO3df2zV9b348VcLttXMVrxcyo9bx9Vd5zYVHEhXHTHedDaZYZc/btaLCxCi87pxjdrsTvAHnXOj3E0NyRVHZO665MYLG5neZZB6Xa9k2bU3ZPxINBcwjjGIWQvcXVqGG5X28/1jWfftKMgp9AXI45GcP/r2/T7nfcybhief86OsKIoiAAAAgFFVfrY3AAAAABcCAQ4AAAAJBDgAAAAkEOAAAACQQIADAABAAgEOAAAACQQ4AAAAJBDgAAAAkECAAwAAQAIBDgAAAAlKDvCf/OQnMWfOnJg8eXKUlZXFSy+99J5rNm3aFB//+MejsrIyPvShD8Xzzz8/gq0CAADA+avkAD9y5EhMmzYtVq1adUrzf/GLX8Ttt98et956a2zfvj3uv//+uOuuu+Lll18uebMAAABwvioriqIY8eKysnjxxRdj7ty5J5zz4IMPxoYNG+KNN94YHPu7v/u7OHToULS3t4/0oQEAAOC8Mna0H6CzszMaGxuHjDU1NcX9999/wjVHjx6No0ePDv48MDAQv/71r+PP/uzPoqysbLS2CgAAABERURRFHD58OCZPnhzl5Wfm49NGPcC7urqitrZ2yFhtbW309vbGb3/727j44ouPW9PW1haPPfbYaG8NAAAATmrfvn3xF3/xF2fkvkY9wEdi6dKl0dLSMvhzT09PXHHFFbFv376orq4+izsDAADgQtDb2xt1dXVx6aWXnrH7HPUAnzhxYnR3dw8Z6+7ujurq6mGvfkdEVFZWRmVl5XHj1dXVAhwAAIA0Z/Jt0KP+PeANDQ3R0dExZOyVV16JhoaG0X5oAAAAOGeUHOC/+c1vYvv27bF9+/aI+P3XjG3fvj327t0bEb9/+fiCBQsG599zzz2xe/fu+PKXvxw7d+6MZ555Jr73ve/FAw88cGaeAQAAAJwHSg7wn/3sZ3HDDTfEDTfcEBERLS0tccMNN8SyZcsiIuJXv/rVYIxHRPzlX/5lbNiwIV555ZWYNm1aPPnkk/Htb387mpqaztBTAAAAgHPfaX0PeJbe3t6oqamJnp4e7wEHAABg1I1Gh476e8ABAAAAAQ4AAAApBDgAAAAkEOAAAACQQIADAABAAgEOAAAACQQ4AAAAJBDgAAAAkECAAwAAQAIBDgAAAAkEOAAAACQQ4AAAAJBAgAMAAEACAQ4AAAAJBDgAAAAkEOAAAACQQIADAABAAgEOAAAACQQ4AAAAJBDgAAAAkECAAwAAQAIBDgAAAAkEOAAAACQQ4AAAAJBAgAMAAEACAQ4AAAAJBDgAAAAkEOAAAACQQIADAABAAgEOAAAACQQ4AAAAJBDgAAAAkECAAwAAQAIBDgAAAAkEOAAAACQQ4AAAAJBAgAMAAEACAQ4AAAAJBDgAAAAkEOAAAACQQIADAABAAgEOAAAACQQ4AAAAJBDgAAAAkECAAwAAQAIBDgAAAAkEOAAAACQQ4AAAAJBAgAMAAEACAQ4AAAAJBDgAAAAkEOAAAACQQIADAABAAgEOAAAACQQ4AAAAJBDgAAAAkECAAwAAQAIBDgAAAAkEOAAAACQQ4AAAAJBAgAMAAEACAQ4AAAAJBDgAAAAkEOAAAACQQIADAABAAgEOAAAACQQ4AAAAJBDgAAAAkECAAwAAQAIBDgAAAAkEOAAAACQQ4AAAAJBAgAMAAEACAQ4AAAAJBDgAAAAkEOAAAACQQIADAABAAgEOAAAACQQ4AAAAJBDgAAAAkECAAwAAQIIRBfiqVati6tSpUVVVFfX19bF58+aTzl+5cmV8+MMfjosvvjjq6urigQceiN/97ncj2jAAAACcj0oO8HXr1kVLS0u0trbG1q1bY9q0adHU1BT79+8fdv4LL7wQS5YsidbW1tixY0c899xzsW7dunjooYdOe/MAAABwvig5wJ966qn4/Oc/H4sWLYqPfvSjsXr16rjkkkviO9/5zrDzX3vttbj55pvjjjvuiKlTp8Ztt90W8+bNe8+r5gAAAPB+UlKA9/X1xZYtW6KxsfGPd1BeHo2NjdHZ2Tnsmptuuim2bNkyGNy7d++OjRs3xqc//enT2DYAAACcX8aWMvngwYPR398ftbW1Q8Zra2tj586dw66544474uDBg/HJT34yiqKIY8eOxT333HPSl6AfPXo0jh49Ovhzb29vKdsEAACAc86ofwr6pk2bYvny5fHMM8/E1q1b4wc/+EFs2LAhHn/88ROuaWtri5qamsFbXV3daG8TAAAARlVZURTFqU7u6+uLSy65JNavXx9z584dHF+4cGEcOnQo/v3f//24NbNnz45PfOIT8c1vfnNw7F//9V/j7rvvjt/85jdRXn78vwEMdwW8rq4uenp6orq6+lS3CwAAACPS29sbNTU1Z7RDS7oCXlFRETNmzIiOjo7BsYGBgejo6IiGhoZh17zzzjvHRfaYMWMiIuJE7V9ZWRnV1dVDbgAAAHA+K+k94BERLS0tsXDhwpg5c2bMmjUrVq5cGUeOHIlFixZFRMSCBQtiypQp0dbWFhERc+bMiaeeeipuuOGGqK+vj7feeiseffTRmDNnzmCIAwAAwPtdyQHe3NwcBw4ciGXLlkVXV1dMnz492tvbBz+Ybe/evUOueD/yyCNRVlYWjzzySLz99tvx53/+5zFnzpz4+te/fuaeBQAAAJzjSnoP+NkyGq+9BwAAgBM56+8BBwAAAEZGgAMAAEACAQ4AAAAJBDgAAAAkEOAAAACQQIADAABAAgEOAAAACQQ4AAAAJBDgAAAAkECAAwAAQAIBDgAAAAkEOAAAACQQ4AAAAJBAgAMAAEACAQ4AAAAJBDgAAAAkEOAAAACQQIADAABAAgEOAAAACQQ4AAAAJBDgAAAAkECAAwAAQAIBDgAAAAkEOAAAACQQ4AAAAJBAgAMAAEACAQ4AAAAJBDgAAAAkEOAAAACQQIADAABAAgEOAAAACQQ4AAAAJBDgAAAAkECAAwAAQAIBDgAAAAkEOAAAACQQ4AAAAJBAgAMAAEACAQ4AAAAJBDgAAAAkEOAAAACQQIADAABAAgEOAAAACQQ4AAAAJBDgAAAAkECAAwAAQAIBDgAAAAkEOAAAACQQ4AAAAJBAgAMAAEACAQ4AAAAJBDgAAAAkEOAAAACQQIADAABAAgEOAAAACQQ4AAAAJBDgAAAAkECAAwAAQAIBDgAAAAkEOAAAACQQ4AAAAJBAgAMAAEACAQ4AAAAJBDgAAAAkEOAAAACQQIADAABAAgEOAAAACQQ4AAAAJBDgAAAAkECAAwAAQAIBDgAAAAkEOAAAACQQ4AAAAJBAgAMAAEACAQ4AAAAJBDgAAAAkEOAAAACQQIADAABAAgEOAAAACQQ4AAAAJBDgAAAAkECAAwAAQIIRBfiqVati6tSpUVVVFfX19bF58+aTzj906FAsXrw4Jk2aFJWVlXH11VfHxo0bR7RhAAAAOB+NLXXBunXroqWlJVavXh319fWxcuXKaGpqil27dsWECROOm9/X1xef+tSnYsKECbF+/fqYMmVK/PKXv4zLLrvsTOwfAAAAzgtlRVEUpSyor6+PG2+8MZ5++umIiBgYGIi6urq49957Y8mSJcfNX716dXzzm9+MnTt3xkUXXTSiTfb29kZNTU309PREdXX1iO4DAAAATtVodGhJL0Hv6+uLLVu2RGNj4x/voLw8Ghsbo7Ozc9g1P/zhD6OhoSEWL14ctbW1ce2118by5cujv7//hI9z9OjR6O3tHXIDAACA81lJAX7w4MHo7++P2traIeO1tbXR1dU17Jrdu3fH+vXro7+/PzZu3BiPPvpoPPnkk/G1r33thI/T1tYWNTU1g7e6urpStgkAAADnnFH/FPSBgYGYMGFCPPvsszFjxoxobm6Ohx9+OFavXn3CNUuXLo2enp7B2759+0Z7mwAAADCqSvoQtvHjx8eYMWOiu7t7yHh3d3dMnDhx2DWTJk2Kiy66KMaMGTM49pGPfCS6urqir68vKioqjltTWVkZlZWVpWwNAAAAzmklXQGvqKiIGTNmREdHx+DYwMBAdHR0RENDw7Brbr755njrrbdiYGBgcOzNN9+MSZMmDRvfAAAA8H5U8kvQW1paYs2aNfHd7343duzYEV/4whfiyJEjsWjRooiIWLBgQSxdunRw/he+8IX49a9/Hffdd1+8+eabsWHDhli+fHksXrz4zD0LAAAAOMeV/D3gzc3NceDAgVi2bFl0dXXF9OnTo729ffCD2fbu3Rvl5X/s+rq6unj55ZfjgQceiOuvvz6mTJkS9913Xzz44INn7lkAAADAOa7k7wE/G3wPOAAAAJnO+veAAwAAACMjwAEAACCBAAcAAIAEAhwAAAASCHAAAABIIMABAAAggQAHAACABAIcAAAAEghwAAAASCDAAQAAIIEABwAAgAQCHAAAABIIcAAAAEggwAEAACCBAAcAAIAEAhwAAAASCHAAAABIIMABAAAggQAHAACABAIcAAAAEghwAAAASCDAAQAAIIEABwAAgAQCHAAAABIIcAAAAEggwAEAACCBAAcAAIAEAhwAAAASCHAAAABIIMABAAAggQAHAACABAIcAAAAEghwAAAASCDAAQAAIIEABwAAgAQCHAAAABIIcAAAAEggwAEAACCB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dHREQ0PDCdd94xvfiMcffzza29tj5syZI98tAAAAnKdKugIeEdHS0hILFy6MmTNnxqxZs2LlypVx5MiRWLRoUURELFiwIKZMmRJtbW0REfFP//RPsWzZsnjhhRdi6tSpg+8V/8AHPhAf+MAHzuBTAQAAgHNXyQHe3NwcBw4ciGXLlkVXV1dMnz492tvbBz+Ybe/evVFe/scL69/61reir68v/vZv/3bI/bS2tsZXvvKV09s9AAAAnCdK/h7ws8H3gAMAAJDprH8POAAAADAyAhwAAAASCHAAAABIIMABAAAggQAHAACABAIcAAAAEghwAAAASCDAAQAAIIEABwAAgAQCHAAAABIIcAAAAEggwAEAACCBAAcAAIAEAhwAAAASCHAAAABIIMABAAAggQAHAACABAIcAAAAEghwAAAASCDAAQAAIIEABwAAgAQCHAAAABIIcAAAAEggwAEAACCBAAcAAIAEAhwAAAASCHAAAABIIMABAAAggQAHAACABAIcAAAAEghwAAAASCDAAQAAIIEABwAAgAQCHAAAABIIcAAAAEggwAEAACCBAAcAAIAEAhwAAAASCHAAAABIIMABAAAggQAHAACABAIcAAAAEghwAAAASCDAAQAAIIEABwAAgAQCHAAAABIIcAAAAEggwAEAACCBAAcAAIAEAhwAAAASCHAAAABIIMABAAAggQAHAACABAIcAAAAEghwAAAASCDAAQAAIIEABwAAgAQCHAAAABIIcAAAAEggwAEAACCBAAcAAIAEAhwAAAASCHAAAABIIMABAAAggQAHAACABAIcAAAAEghwAAAASCDAAQAAIIEABwAAgAQCHAAAABIIcAAAAEggwAEAACCBAAcAAIAEAhwAAAASCHAAAABIIMABAAAggQAHAACABAIcAAAAEghwAAAASCDAAQAAIIEABwAAgAQjCvBVq1bF1KlTo6qqKurr62Pz5s0nnf/9738/rrnmmqiqqorrrrsuNm7cOKLNAgAAwPmq5ABft25dtLS0RGtra2zdujWmTZsWTU1NsX///mHnv/baazFv3ry48847Y9u2bTF37tyYO3duvPHGG6e9eQAAADhflBVFUZSyoL6+Pm688cZ4+umnIyJiYGAg6urq4t57740lS5YcN7+5uTmOHDkSP/rRjwbHPvGJT8T06dNj9erVp/SYvb29UVNTEz09PVFdXV3KdgEAAKBko9GhY0uZ3NfXF1u2bImlS5cOjpWXl0djY2N0dnYOu6azszNaWlqGjDU1NcVLL710wsc5evRoHD16dPDnnp6eiPj9/wAAAAAYbX/ozxKvWZ9USQF+8ODB6O/vj9ra2iHjtbW1sXPnzmHXdHV1DTu/q6vrhI/T1tYWjz322HHjdXV1pWwXAAAATsv//u//Rk1NzRm5r5ICPMvSpUuHXDU/dOhQfPCDH4y9e/eesScO55re3t6oq6uLffv2easF71vOORcC55wLgXPOhaCnpyeuuOKKuPzyy8/YfZYU4OPHj48xY8ZEd3f3kPHu7u6YOHHisGsmTpxY0vyIiMrKyqisrDxuvKamxh9w3veqq6udc973nHMuBM45FwLnnAtBefmZ+/buku6poqIiZsyYER0dHYNjAwMD0dHREQ0NDcOuaWhoGDI/IuKVV1454XwAAAB4Pyr5JegtLS2xcOHCmDlzZsyaNStWrlwZR44ciUWLFkVExIIFC2LKlCnR1tYWERH33Xdf3HLLLfHkk0/G7bffHmvXro2f/exn8eyzz57ZZwIAAADnsJIDvLm5OQ4cOBDLli2Lrq6umD59erS3tw9+0NrevXuHXKK/6aab4oUXXohHHnkkHnroofirv/qreOmll+Laa6895cesrKyM1tbWYV+WDu8XzjkXAuecC4FzzoXAOedCMBrnvOTvAQcAAABKd+beTQ4AAACckAAHAACABAIcAAAAEghwAAAASHDOBPiqVati6tSpUVVVFfX19bF58+aTzv/+978f11xzTVRVVcV1110XGzduTNopjFwp53zNmjUxe/bsGDduXIwbNy4aGxvf888FnAtK/X3+B2vXro2ysrKYO3fu6G4QzoBSz/mhQ4di8eLFMWnSpKisrIyrr77a310455V6zleuXBkf/vCH4+KLL466urp44IEH4ne/+13SbqE0P/nJT2LOnDkxefLkKCsri5deeuk912zatCk+/vGPR2VlZXzoQx+K559/vuTHPScCfN26ddHS0hKtra2xdevWmDZtWjQ1NcX+/fuHnf/aa6/FvHnz4s4774xt27bF3LlzY+7cufHGG28k7xxOXannfNOmTTFv3rx49dVXo7OzM+rq6uK2226Lt99+O3nncOpKPed/sGfPnvjSl74Us2fPTtopjFyp57yvry8+9alPxZ49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",
      "text/plain": [
       "<Figure size 1200x600 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "if __name__ == \"__main__\":\n",
    "    try:\n",
    "        data_path = \"/kaggle/input/ariel-data-challenge-2024\"\n",
    "        results_path = \"/kaggle/working\"\n",
    "        train_adc_info = pd.read_csv(f\"{data_path}/train_adc_info.csv\", index_col='planet_id')\n",
    "        axis_info = pd.read_parquet(f\"{data_path}/axis_info.parquet\")\n",
    "        \n",
    "        logging.info(\"Starting planet processing\")\n",
    "        process_all_planets(data_path, results_path, train_adc_info, axis_info)\n",
    "        \n",
    "        logging.info(\"Loading processed results\")\n",
    "        all_results = load_processed_results(results_path, train_adc_info.index)\n",
    "        \n",
    "        logging.info(\"Preparing data for modeling\")\n",
    "        X, y = prepare_data_for_modeling(all_results)\n",
    "        \n",
    "        logging.info(\"Training and evaluating models\")\n",
    "        lr_model, rf_model, pca_model, X_test_pca, y_test = train_and_evaluate_models(X, y)\n",
    "        \n",
    "        logging.info(\"Selecting best model\")\n",
    "        best_model = select_best_model(lr_model, rf_model, X_test_pca, y_test)\n",
    "        \n",
    "        logging.info(\"Preparing submission\")\n",
    "        prepare_submission(best_model, pca_model, all_results, \"submission.csv\")\n",
    "\n",
    "        logging.info(\"Visualizing results\")\n",
    "        wavelengths = list(all_results.values())[0]['wavelengths']\n",
    "        visualize_important_features(best_model, pca_model, wavelengths)\n",
    "        \n",
    "        example_planet_id = list(all_results.keys())[0]\n",
    "        plot_example_prediction(best_model, pca_model, all_results, example_planet_id)\n",
    "        \n",
    "        logging.info(\"Analysis completed successfully\")\n",
    "    except Exception as e:\n",
    "        logging.error(f\"An error occurred: {str(e)}\", exc_info=True)"
   ]
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "gpu",
   "dataSources": [
    {
     "databundleVersionId": 9188054,
     "sourceId": 70367,
     "sourceType": "competition"
    }
   ],
   "dockerImageVersionId": 30761,
   "isGpuEnabled": true,
   "isInternetEnabled": false,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.14"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 9600.756028,
   "end_time": "2024-09-11T18:15:56.471347",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2024-09-11T15:35:55.715319",
   "version": "2.6.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
