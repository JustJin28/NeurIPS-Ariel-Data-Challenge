{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "ce20aff7",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-13T12:46:59.355877Z",
     "iopub.status.busy": "2024-09-13T12:46:59.354855Z",
     "iopub.status.idle": "2024-09-13T12:47:01.512257Z",
     "shell.execute_reply": "2024-09-13T12:47:01.511435Z"
    },
    "papermill": {
     "duration": 2.165319,
     "end_time": "2024-09-13T12:47:01.514566",
     "exception": false,
     "start_time": "2024-09-13T12:46:59.349247",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Ariel Data Challenge 2024: Exoplanet Spectrum Analysis Pipeline\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy import signal\n",
    "from scipy.ndimage import gaussian_filter1d\n",
    "from scipy.optimize import minimize\n",
    "from scipy.signal import savgol_filter\n",
    "from scipy.interpolate import interp1d\n",
    "from sklearn.decomposition import PCA\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.linear_model import LinearRegression\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "from sklearn.metrics import mean_squared_error, r2_score\n",
    "import gc\n",
    "import logging\n",
    "from tqdm.notebook import tqdm"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "71c43af5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-13T12:47:01.523706Z",
     "iopub.status.busy": "2024-09-13T12:47:01.523289Z",
     "iopub.status.idle": "2024-09-13T12:47:01.529246Z",
     "shell.execute_reply": "2024-09-13T12:47:01.528390Z"
    },
    "papermill": {
     "duration": 0.012521,
     "end_time": "2024-09-13T12:47:01.531243",
     "exception": false,
     "start_time": "2024-09-13T12:47:01.518722",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 1. Data Loading Functions\n",
    "\n",
    "def load_planet_data(planet_id, data_path):\n",
    "    airs_signal = pd.read_parquet(f\"{data_path}/train/{planet_id}/AIRS-CH0_signal.parquet\")\n",
    "    fgs1_signal = pd.read_parquet(f\"{data_path}/train/{planet_id}/FGS1_signal.parquet\")\n",
    "    \n",
    "    calibration_files = {\n",
    "        'dark': pd.read_parquet(f\"{data_path}/train/{planet_id}/AIRS-CH0_calibration/dark.parquet\"),\n",
    "        'flat': pd.read_parquet(f\"{data_path}/train/{planet_id}/AIRS-CH0_calibration/flat.parquet\"),\n",
    "        'dead': pd.read_parquet(f\"{data_path}/train/{planet_id}/AIRS-CH0_calibration/dead.parquet\"),\n",
    "        'linear_corr': pd.read_parquet(f\"{data_path}/train/{planet_id}/AIRS-CH0_calibration/linear_corr.parquet\")\n",
    "    }\n",
    "    \n",
    "    return airs_signal, fgs1_signal, calibration_files"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "93802013",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-13T12:47:01.539874Z",
     "iopub.status.busy": "2024-09-13T12:47:01.539607Z",
     "iopub.status.idle": "2024-09-13T12:47:01.551720Z",
     "shell.execute_reply": "2024-09-13T12:47:01.550927Z"
    },
    "papermill": {
     "duration": 0.018659,
     "end_time": "2024-09-13T12:47:01.553572",
     "exception": false,
     "start_time": "2024-09-13T12:47:01.534913",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 2. Data Preprocessing Functions\n",
    "\n",
    "def reshape_and_calibrate(airs_signal, calibration_files):\n",
    "    airs_data = airs_signal.values.reshape(-1, 32, 356)\n",
    "    airs_data = (airs_data - calibration_files['dark'].values) / calibration_files['flat'].values\n",
    "    return airs_data\n",
    "\n",
    "def extract_spectral_data(airs_data):\n",
    "    return np.mean(airs_data, axis=1)\n",
    "\n",
    "def measure_centroid(image):\n",
    "    y, x = np.indices(image.shape)\n",
    "    total = image.sum()\n",
    "    x_center = (x * image).sum() / total\n",
    "    y_center = (y * image).sum() / total\n",
    "    return x_center, y_center\n",
    "\n",
    "def correct_jitter(airs_data, fgs1_data, airs_time, fgs1_time):\n",
    "    # Ensure FGS1 data covers the full AIRS-CH0 time range\n",
    "    fgs1_start = max(fgs1_time.min(), airs_time.min())\n",
    "    fgs1_end = min(fgs1_time.max(), airs_time.max())\n",
    "    mask = (fgs1_time >= fgs1_start) & (fgs1_time <= fgs1_end)\n",
    "    fgs1_time = fgs1_time[mask]\n",
    "    fgs1_data = fgs1_data[mask]\n",
    "\n",
    "    # Interpolate FGS1 centroid positions to AIRS-CH0 timestamps\n",
    "    interp_x = interp1d(fgs1_time, fgs1_data[:, 0], kind='cubic', fill_value='extrapolate')\n",
    "    interp_y = interp1d(fgs1_time, fgs1_data[:, 1], kind='cubic', fill_value='extrapolate')\n",
    "    \n",
    "    x_pos = interp_x(airs_time)\n",
    "    y_pos = interp_y(airs_time)\n",
    "\n",
    "    # Smooth the centroid positions to reduce noise\n",
    "    x_smooth = savgol_filter(x_pos, window_length=51, polyorder=3)\n",
    "    y_smooth = savgol_filter(y_pos, window_length=51, polyorder=3)\n",
    "\n",
    "    # Calculate pixel shifts\n",
    "    x_shift = x_smooth - np.median(x_smooth)\n",
    "    y_shift = y_smooth - np.median(y_smooth)\n",
    "\n",
    "    # Correct AIRS-CH0 data for jitter\n",
    "    corrected_data = np.zeros_like(airs_data)\n",
    "    for i in range(airs_data.shape[1]):\n",
    "        # Create a 2D interpolation function for each wavelength\n",
    "        interp_func = interp1d(airs_time, airs_data[:, i], kind='cubic', fill_value='extrapolate')\n",
    "        \n",
    "        # Apply correction\n",
    "        corrected_time = airs_time - x_shift * 0.1 - y_shift * 0.1  # Adjust scaling factors as needed\n",
    "        corrected_data[:, i] = interp_func(corrected_time)\n",
    "\n",
    "    return corrected_data\n",
    "\n",
    "def normalize_data(data):\n",
    "    mean = np.mean(data, axis=0)\n",
    "    std = np.std(data, axis=0)\n",
    "    return (data - mean) / (std + 1e-10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "592a64f7",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-13T12:47:01.562118Z",
     "iopub.status.busy": "2024-09-13T12:47:01.561588Z",
     "iopub.status.idle": "2024-09-13T12:47:01.574050Z",
     "shell.execute_reply": "2024-09-13T12:47:01.573218Z"
    },
    "papermill": {
     "duration": 0.018817,
     "end_time": "2024-09-13T12:47:01.575952",
     "exception": false,
     "start_time": "2024-09-13T12:47:01.557135",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 3. Model Building Functions\n",
    "\n",
    "def simple_transit_model(params, time):\n",
    "    t0, per, depth, duration = params\n",
    "    phase = (time - t0 + 0.5*per) % per - 0.5*per\n",
    "    transit = np.abs(phase) < 0.5*duration\n",
    "    return 1 - depth * transit\n",
    "\n",
    "def fit_transit_model(flux, time):\n",
    "    def residuals(params):\n",
    "        return np.sum((flux - simple_transit_model(params, time))**2)\n",
    "    \n",
    "    initial_guess = [np.median(time), 0.1 * (time[-1] - time[0]), 0.01, 0.1 * (time[-1] - time[0])]\n",
    "    bounds = ((0, len(time)), (0, len(time)), (0, 0.1), (0, len(time)/2))\n",
    "    result = minimize(residuals, initial_guess, bounds=bounds, method='L-BFGS-B')\n",
    "    return result.x\n",
    "\n",
    "def process_planet(planet_id, data_path, axis_info):\n",
    "    # Load data\n",
    "    airs_signal, fgs1_signal, calibration_files = load_planet_data(planet_id, data_path)\n",
    "    \n",
    "    # Preprocess data\n",
    "    airs_data = reshape_and_calibrate(airs_signal, calibration_files)\n",
    "    spectral_data = extract_spectral_data(airs_data)\n",
    "    \n",
    "    # Time arrays\n",
    "    airs_time_step = axis_info['AIRS-CH0-axis0-h'].iloc[1] - axis_info['AIRS-CH0-axis0-h'].iloc[0]\n",
    "    time = np.arange(len(spectral_data)) * airs_time_step\n",
    "    \n",
    "    fgs1_data = fgs1_signal.values.reshape(-1, 32, 32)\n",
    "    fgs1_centroids = np.array([measure_centroid(frame) for frame in fgs1_data])\n",
    "    fgs1_time_step = axis_info['FGS1-axis0-h'].iloc[1] - axis_info['FGS1-axis0-h'].iloc[0]\n",
    "    fgs1_time = np.arange(len(fgs1_data)) * fgs1_time_step\n",
    "    \n",
    "    # Jitter correction\n",
    "    corrected_spectral_data = correct_jitter(spectral_data, fgs1_centroids, time, fgs1_time)\n",
    "    \n",
    "    # Fit transit model for each wavelength\n",
    "    transit_params = np.array([fit_transit_model(corrected_spectral_data[:, i], time) \n",
    "                               for i in range(corrected_spectral_data.shape[1])])\n",
    "    \n",
    "    # Extract spectrum and estimate uncertainties\n",
    "    spectrum = np.mean(corrected_spectral_data, axis=0)\n",
    "    uncertainties = np.std(corrected_spectral_data, axis=0) / np.sqrt(len(corrected_spectral_data))\n",
    "    \n",
    "    return {\n",
    "        'wavelengths': pd.read_csv(f\"{data_path}/wavelengths.csv\").iloc[0].values,\n",
    "        'spectrum': spectrum,\n",
    "        'uncertainties': uncertainties,\n",
    "        'transit_params': transit_params\n",
    "    }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "2b29d2af",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-13T12:47:01.584380Z",
     "iopub.status.busy": "2024-09-13T12:47:01.584077Z",
     "iopub.status.idle": "2024-09-13T12:47:01.589734Z",
     "shell.execute_reply": "2024-09-13T12:47:01.588918Z"
    },
    "papermill": {
     "duration": 0.011963,
     "end_time": "2024-09-13T12:47:01.591591",
     "exception": false,
     "start_time": "2024-09-13T12:47:01.579628",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 4. Main Processing Loop\n",
    "def process_all_planets(data_path, train_adc_info, axis_info):\n",
    "    all_results = {}\n",
    "    total_planets = len(train_adc_info.index)\n",
    "    \n",
    "    for i, planet_id in enumerate(tqdm(train_adc_info.index, desc=\"Processing planets\")):\n",
    "        results = process_planet(str(planet_id), data_path, axis_info)\n",
    "        if results is not None:\n",
    "            all_results[planet_id] = results\n",
    "        \n",
    "        # Optional: Print progress every 10%\n",
    "        if (i + 1) % (total_planets // 10) == 0:\n",
    "            print(f\"Processed {i + 1}/{total_planets} planets\")\n",
    "    \n",
    "    return all_results"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "483ab2cd",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-13T12:47:01.599799Z",
     "iopub.status.busy": "2024-09-13T12:47:01.599521Z",
     "iopub.status.idle": "2024-09-13T12:47:01.608467Z",
     "shell.execute_reply": "2024-09-13T12:47:01.607614Z"
    },
    "papermill": {
     "duration": 0.015139,
     "end_time": "2024-09-13T12:47:01.610293",
     "exception": false,
     "start_time": "2024-09-13T12:47:01.595154",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 5. Model Evaluation and Analysis\n",
    "\n",
    "def load_processed_results(results_path, planet_ids):\n",
    "    all_results = {}\n",
    "    for planet_id in planet_ids:\n",
    "        all_results[planet_id] = np.load(f\"{results_path}/planet_{planet_id}_results.npz\", allow_pickle=True)\n",
    "    return all_results\n",
    "\n",
    "def prepare_data_for_modeling(all_results):\n",
    "    X = np.array([results['spectrum'] for results in all_results.values()])\n",
    "    y = np.array([results['transit_params'][:, 2] for results in all_results.values()])  # Using transit depth as target\n",
    "    return X, y\n",
    "\n",
    "def train_and_evaluate_models(X, y):\n",
    "    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n",
    "    \n",
    "    # PCA\n",
    "    pca = PCA(n_components=0.95)\n",
    "    X_train_pca = pca.fit_transform(X_train)\n",
    "    X_test_pca = pca.transform(X_test)\n",
    "    \n",
    "    # Linear Regression\n",
    "    lr = LinearRegression()\n",
    "    lr.fit(X_train_pca, y_train)\n",
    "    lr_score = lr.score(X_test_pca, y_test)\n",
    "    \n",
    "    # Random Forest\n",
    "    rf = RandomForestRegressor(n_estimators=100, random_state=42)\n",
    "    rf.fit(X_train_pca, y_train)\n",
    "    rf_score = rf.score(X_test_pca, y_test)\n",
    "    \n",
    "    print(f\"Linear Regression R2 Score: {lr_score:.4f}\")\n",
    "    print(f\"Random Forest R2 Score: {rf_score:.4f}\")\n",
    "    \n",
    "    return lr, rf, pca, X_test_pca, y_test"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "e0973bef",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-13T12:47:01.618743Z",
     "iopub.status.busy": "2024-09-13T12:47:01.618126Z",
     "iopub.status.idle": "2024-09-13T12:47:01.623315Z",
     "shell.execute_reply": "2024-09-13T12:47:01.622499Z"
    },
    "papermill": {
     "duration": 0.011378,
     "end_time": "2024-09-13T12:47:01.625242",
     "exception": false,
     "start_time": "2024-09-13T12:47:01.613864",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 5.2. Final Model Selection\n",
    "\n",
    "def select_best_model(lr_model, rf_model, X_test_pca, y_test):\n",
    "    lr_mse = mean_squared_error(y_test, lr_model.predict(X_test_pca))\n",
    "    rf_mse = mean_squared_error(y_test, rf_model.predict(X_test_pca))\n",
    "    \n",
    "    print(f\"Linear Regression MSE: {lr_mse:.6f}\")\n",
    "    print(f\"Random Forest MSE: {rf_mse:.6f}\")\n",
    "    \n",
    "    if lr_mse < rf_mse:\n",
    "        print(\"Linear Regression model selected.\")\n",
    "        return lr_model\n",
    "    else:\n",
    "        print(\"Random Forest model selected.\")\n",
    "        return rf_model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "3b82ff3e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-13T12:47:01.633390Z",
     "iopub.status.busy": "2024-09-13T12:47:01.633093Z",
     "iopub.status.idle": "2024-09-13T12:47:01.639928Z",
     "shell.execute_reply": "2024-09-13T12:47:01.639231Z"
    },
    "papermill": {
     "duration": 0.012946,
     "end_time": "2024-09-13T12:47:01.641756",
     "exception": false,
     "start_time": "2024-09-13T12:47:01.628810",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 5.4. Uncertainty Estimation\n",
    "\n",
    "def estimate_uncertainty(model, X_pca, n_bootstrap=100):\n",
    "    predictions = []\n",
    "    for _ in range(n_bootstrap):\n",
    "        if isinstance(model, RandomForestRegressor):\n",
    "            # Randomly select estimators and average their predictions\n",
    "            n_estimators = len(model.estimators_)\n",
    "            selected_estimators = np.random.choice(model.estimators_, size=n_estimators, replace=True)\n",
    "            preds = np.mean([estimator.predict(X_pca) for estimator in selected_estimators], axis=0)\n",
    "        elif isinstance(model, LinearRegression):\n",
    "            # Add noise to the coefficients\n",
    "            coef_noise = np.random.normal(0, 0.1, size=model.coef_.shape)\n",
    "            preds = X_pca @ (model.coef_ + coef_noise).T + model.intercept_\n",
    "        else:\n",
    "            raise ValueError(\"Unsupported model type\")\n",
    "        predictions.append(preds)\n",
    "    \n",
    "    return np.std(predictions, axis=0)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "4d79621a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-13T12:47:01.650020Z",
     "iopub.status.busy": "2024-09-13T12:47:01.649725Z",
     "iopub.status.idle": "2024-09-13T12:47:01.656981Z",
     "shell.execute_reply": "2024-09-13T12:47:01.656285Z"
    },
    "papermill": {
     "duration": 0.013412,
     "end_time": "2024-09-13T12:47:01.658789",
     "exception": false,
     "start_time": "2024-09-13T12:47:01.645377",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 5.6. Submission Preparation\n",
    "\n",
    "def prepare_submission(model, pca_model, all_results, output_file):\n",
    "    planet_ids = list(all_results.keys())\n",
    "    spectra = []\n",
    "    uncertainties = []\n",
    "    \n",
    "    for planet_id in planet_ids:\n",
    "        spectrum = all_results[planet_id]['spectrum']\n",
    "        spectrum_pca = pca_model.transform(spectrum.reshape(1, -1))\n",
    "        predicted_spectrum = model.predict(spectrum_pca).flatten()\n",
    "        spectrum_uncertainty = estimate_uncertainty(model, spectrum_pca)\n",
    "        \n",
    "        # Ensure the predicted spectrum and uncertainty have the correct shape\n",
    "        if predicted_spectrum.ndim == 2:\n",
    "            predicted_spectrum = predicted_spectrum[0]\n",
    "        if spectrum_uncertainty.ndim == 2:\n",
    "            spectrum_uncertainty = spectrum_uncertainty[0]\n",
    "        \n",
    "        spectra.append(predicted_spectrum)\n",
    "        uncertainties.append(spectrum_uncertainty)\n",
    "    \n",
    "    submission_df = pd.DataFrame({\n",
    "        'planet_id': planet_ids,\n",
    "        'spectrum': spectra,\n",
    "        'uncertainty': uncertainties\n",
    "    })\n",
    "    \n",
    "    submission_df.to_csv(output_file, index=False)\n",
    "    print(f\"Submission file saved to {output_file}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "a25d5d5a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-09-13T12:47:01.666837Z",
     "iopub.status.busy": "2024-09-13T12:47:01.666567Z",
     "iopub.status.idle": "2024-09-13T15:26:37.749528Z",
     "shell.execute_reply": "2024-09-13T15:26:37.748426Z"
    },
    "papermill": {
     "duration": 9576.093494,
     "end_time": "2024-09-13T15:26:37.755808",
     "exception": false,
     "start_time": "2024-09-13T12:47:01.662314",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Starting planet processing\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "7b3c630d9c0a41d5b28358b0fa3e896e",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Processing planets:   0%|          | 0/673 [00:00<?, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Processed 67/673 planets\n",
      "Processed 134/673 planets\n",
      "Processed 201/673 planets\n",
      "Processed 268/673 planets\n",
      "Processed 335/673 planets\n",
      "Processed 402/673 planets\n",
      "Processed 469/673 planets\n",
      "Processed 536/673 planets\n",
      "Processed 603/673 planets\n",
      "Processed 670/673 planets\n",
      "Preparing data for modeling\n",
      "Shape of X: (673, 356)\n",
      "Shape of y: (673, 356)\n",
      "Training and evaluating models\n",
      "Linear Regression R2 Score: -0.0013\n",
      "Random Forest R2 Score: 0.5081\n",
      "Number of PCA components: 2\n",
      "Shape of X_test_pca: (135, 2)\n",
      "Selecting best model\n",
      "Linear Regression MSE: 0.001128\n",
      "Random Forest MSE: 0.000528\n",
      "Random Forest model selected.\n",
      "Preparing submission\n",
      "Submission file saved to submission.csv\n",
      "Analysis completed successfully\n"
     ]
    }
   ],
   "source": [
    "if __name__ == \"__main__\":\n",
    "    try:\n",
    "        data_path = \"/kaggle/input/ariel-data-challenge-2024\"\n",
    "        train_adc_info = pd.read_csv(f\"{data_path}/train_adc_info.csv\", index_col='planet_id')\n",
    "        axis_info = pd.read_parquet(f\"{data_path}/axis_info.parquet\")\n",
    "        \n",
    "        print(\"Starting planet processing\")\n",
    "        all_results = process_all_planets(data_path, train_adc_info, axis_info)\n",
    "        \n",
    "        print(\"Preparing data for modeling\")\n",
    "        X, y = prepare_data_for_modeling(all_results)\n",
    "        print(f\"Shape of X: {X.shape}\")\n",
    "        print(f\"Shape of y: {y.shape}\")\n",
    "\n",
    "        print(\"Training and evaluating models\")\n",
    "        lr_model, rf_model, pca_model, X_test_pca, y_test = train_and_evaluate_models(X, y)\n",
    "        print(f\"Number of PCA components: {pca_model.n_components_}\")\n",
    "        print(f\"Shape of X_test_pca: {X_test_pca.shape}\")\n",
    "\n",
    "        print(\"Selecting best model\")\n",
    "        best_model = select_best_model(lr_model, rf_model, X_test_pca, y_test)\n",
    "        \n",
    "        print(\"Preparing submission\")\n",
    "        prepare_submission(best_model, pca_model, all_results, \"submission.csv\")\n",
    "\n",
    "        print(\"Analysis completed successfully\")\n",
    "    except Exception as e:\n",
    "        print(f\"An error occurred: {str(e)}\")\n",
    "        raise"
   ]
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "gpu",
   "dataSources": [
    {
     "databundleVersionId": 9188054,
     "sourceId": 70367,
     "sourceType": "competition"
    }
   ],
   "dockerImageVersionId": 30761,
   "isGpuEnabled": true,
   "isInternetEnabled": false,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.14"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 9581.88127,
   "end_time": "2024-09-13T15:26:38.484646",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2024-09-13T12:46:56.603376",
   "version": "2.6.0"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {
     "2773ee2fe3844b6a9b27b282d15f8b79": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "1.2.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "overflow_x": null,
       "overflow_y": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "3fd07510b38c42ac8395f6060b6d8892": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "1.5.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_tooltip": null,
       "layout": "IPY_MODEL_cb63bd90cb2c4f0d85b4cb8ab853f80e",
       "placeholder": "​",
       "style": "IPY_MODEL_4577d635916f40b58a6479c5d4993c02",
       "value": "Processing planets: 100%"
      }
     },
     "4577d635916f40b58a6479c5d4993c02": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "DescriptionStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "DescriptionStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "StyleView",
       "description_width": ""
      }
     },
     "4998de474c97465084c0d5db580c4816": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "1.5.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_tooltip": null,
       "layout": "IPY_MODEL_f89b849ad5704868ae80c964f7c6ef8d",
       "placeholder": "​",
       "style": "IPY_MODEL_77fc0df4b2f047659c632835b71290b8",
       "value": " 673/673 [2:31:07&lt;00:00, 13.56s/it]"
      }
     },
     "563f895dcfe24f2e9a4d0acc0c1da102": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "1.2.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "overflow_x": null,
       "overflow_y": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "6f46a2e96ff2449084c6cae6695f5588": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     },
     "77fc0df4b2f047659c632835b71290b8": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "DescriptionStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "DescriptionStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "StyleView",
       "description_width": ""
      }
     },
     "7b3c630d9c0a41d5b28358b0fa3e896e": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "1.5.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_3fd07510b38c42ac8395f6060b6d8892",
        "IPY_MODEL_af5359a64d014db9807ebc1e4e981586",
        "IPY_MODEL_4998de474c97465084c0d5db580c4816"
       ],
       "layout": "IPY_MODEL_563f895dcfe24f2e9a4d0acc0c1da102"
      }
     },
     "af5359a64d014db9807ebc1e4e981586": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "1.5.0",
       "_view_name": "ProgressView",
       "bar_style": "success",
       "description": "",
       "description_tooltip": null,
       "layout": "IPY_MODEL_2773ee2fe3844b6a9b27b282d15f8b79",
       "max": 673.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_6f46a2e96ff2449084c6cae6695f5588",
       "value": 673.0
      }
     },
     "cb63bd90cb2c4f0d85b4cb8ab853f80e": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "1.2.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "overflow_x": null,
       "overflow_y": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "f89b849ad5704868ae80c964f7c6ef8d": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "1.2.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "overflow_x": null,
       "overflow_y": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     }
    },
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
